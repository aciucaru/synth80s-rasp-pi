#ifndef SYNTH80S_SRC_RPI_SEQUENCER_SYNTH_H

#define SYNTH80S_SRC_RPI_SEQUENCER_SYNTH_H

#include "../audio/core/audio-context.h"
#include "../audio/core/audio-processor.h"
#include "../audio/synth/mono-synth.h"
#include "../audio/sequencer/step-signal.h"
#include "../audio/sequencer/asr-step-signal.h"
#include "../audio/sequencer/note-sequence-factory.h"
#include "../audio/note/note.h"
#include "ui/synth-hardware-manager.h"

#include <array>
#include <vector>

namespace synth80s
{
  class SequencerSynth: public AudioProcessor
  {
    private:
      // Main sound generator
      synth80s::MonoSynth monoSynth;

      // The step signal generator
      synth80s::StepSignal stepSignal;
      synth80s::AsrStepSignal asrStepSignal;

	  static const int STEP_COUNT = 8;
      // The array of notes; this synthesizer allows for maximum 8 steps
      std::array<Note, SequencerSynth::STEP_COUNT> noteArray;
      
      // The factory that returns a note sequence (arrpegio)
      NoteSequenceFactory noteSequenceFactory;
      
      // The array of semitones offsets from the selected sequence.
      std::array<int, SequencerSynth::STEP_COUNT> sequenceSemitoneOffsetArray;

      // The array of semitones offsets from the user.
      // The final semitones offset will be a sum of both 'sequence'
      std::array<int, SequencerSynth::STEP_COUNT> userSemitoneOffsetArray;

      // The reader of the values form potentiometers and buttons
      SynthHardwareManager paramReader;

      // The gain of the oscillator, this is a multiplier used to increase or lower the
      // volume of the socillator
      float gain = 1.0f;

      // The actual block (array) of audio samples generated by this class
      float* outputBlock = nullptr;

    public:
      // constructor, must receive AudioContext as external dependecy
      SequencerSynth(AudioContext* audioContext);

      /* implementation of virtual (abstract) method, inherited from 'AudioProcessor' class;
      ** the signal is stored into the 'block' buffer inherited from 'AudioNode' class;
      ** this method is responsible for generating the actual synth sound; */
      void process(float* inputBlock = nullptr) override;

      // implementation of abstract method, inherited from 'AudioProcessor' class
      float* getProcessedOutput() override;
  };
}

#endif
